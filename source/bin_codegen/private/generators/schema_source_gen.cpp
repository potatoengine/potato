// Copyright by Potato Engine contributors. See accompanying License.txt for copyright details.

#include "../cxx.h"
#include "../generator.h"
#include "../schema.h"

#include <memory>
#include <ostream>

namespace {
    class SchemaSourceGenerator final : public Generator {
    public:
        using Generator::Generator;

        bool generate() override;

    private:
        void writeFileHeader();
        void writeFileFooter();
        void writeIncludes();
        void writeReflex();
        void writeAnnotations(std::string_view unique, schema::Annotations const& annotations);
        void writeSchema();

        bool allowType(schema::TypeBase const& type) const noexcept;
        bool allowAttribute(schema::TypeAggregate const& attribute) const noexcept;
    };
} // namespace

std::unique_ptr<Generator> newSchemaSourceGenerator(GeneratorContext const& ctx) {
    return std::make_unique<SchemaSourceGenerator>(ctx);
}

bool SchemaSourceGenerator::generate() {
    writeFileHeader();
    writeIncludes();
    writeReflex();
    writeSchema();
    writeFileFooter();

    return true;
}

void SchemaSourceGenerator::writeFileHeader() {
    _output << "// --- GENERATED FILE ----\n"
               "// - Do not edit this file\n"
               "//\n\n";

    _output << "#ifdef __GNUC__\n"
               "#pragma GCC diagnostic push\n"
               "#pragma GCC diagnostic ignored \"-Winvalid-offsetof\"\n"
               "#endif\n\n";
}

void SchemaSourceGenerator::writeFileFooter() {
    _output << "#ifdef __GNUC__\n"
               "#    pragma GCC diagnostic pop\n"
               "#endif\n\n";
}

void SchemaSourceGenerator::writeIncludes() {
    _output << "#include \"" << config("MODULE_HEADER") << "\"\n\n";
}

void SchemaSourceGenerator::writeReflex() {
    using namespace schema;

    _output << "\n// Type Infos\n\n";

    for (TypeBase const* type : _module.exportedTypes) {
        if (!allowType(*type)) {
            continue;
        }

        // hack because specialized types aren't owned by correct module
        //
        if (type->kind == TypeKind::Alias) {
            type = static_cast<schema::TypeIndirect const*>(type)->ref;
        }

        _output << "up::reflex::TypeInfo const& up::reflex::TypeHolder<" << cxx::Type{*type} << ">::get() noexcept {\n";
        _output << "  using namespace up::schema;\n";
        _output << "  static TypeInfo const info = makeTypeInfo<" << cxx::Type{*type} << ">(\"" << type->qualifiedName
                << "\"_zsv, &getSchema<" << cxx::Type{*type} << ">());\n";
        _output << "  return info;\n";
        _output << "}\n\n";
    }
}

void SchemaSourceGenerator::writeAnnotations(std::string_view unique, schema::Annotations const& annotations) {
    size_t annotationIndex = 0;
    for (auto const* const anno : annotations) {
        auto const& type = *anno->type;

        if (!allowAttribute(type)) {
            continue;
        }

        _output << "  static const " << cxx::Type{type} << " annotation_" << annotationIndex << "_"
                << cxx::Ident{unique} << " {\n ";
        for (size_t argIndex = 0; argIndex != anno->args.size(); ++argIndex) {
            auto const& field = *type.fields[argIndex];
            auto const& arg = anno->args[argIndex];
            _output << "    ." << cxx::Ident{field.name} << " = " << cxx::Value{arg} << ",\n";
        }
        _output << "  };\n";

        ++annotationIndex;
    }

    if (annotationIndex == 0) {
        _output << "  static const up::view<SchemaAnnotation> " << cxx::Ident{unique} << ";\n\n";
        return;
    }

    _output << "  static const SchemaAnnotation " << cxx::Ident{unique} << "[] = {\n";

    annotationIndex = 0;
    for (auto const* const anno : annotations) {
        auto const& type = *anno->type;

        if (!allowAttribute(type)) {
            continue;
        }

        _output << "    {.type = &getTypeInfo<" << cxx::Type{type} << ">(), .attr = &annotation_" << annotationIndex++
                << "_" << cxx::Ident{unique} << "},\n";
    }

    _output << "  };\n\n";
}

//        elif type.has_annotation('AssetReference'):
//            ctx.print(f'''
//        using Type = {qual_name};
//        using AssetType = typename Type::AssetType;
//        static SchemaOperations const operations = {{
//            .pointerDeref = [](void const* ptr) -> void const* {
//    { return static_cast<Type const*>(ptr)->asset(); }},
//            .pointerMutableDeref = [](void* ptr) -> void* {
//    { return static_cast<Type const*>(ptr)->asset(); }},
//            .pointerAssign = [](void* ptr,
//                                void* object) {
//    { *static_cast<Type*>(ptr) = Type{{rc{{static_cast<AssetType*>(object)}}}}; }},
//        }};
//''')
//            ctx.print(f'    static const Schema schema = {{.name = "{type.name}"_zsv, .primitive =
//            up::reflex::SchemaPrimitive::AssetRef, .baseSchema = base, .operations = &operations, .annotations =
//            {type.name}_annotations}};\n')

void SchemaSourceGenerator::writeSchema() {
    using namespace schema;

    _output << "\n// Schemas\n\n";

    for (TypeBase const* type : _module.exportedTypes) {
        if (!allowType(*type)) {
            continue;
        }

        // hack because specialized types aren't owned by correct module
        //
        if (type->kind == TypeKind::Alias) {
            type = static_cast<schema::TypeIndirect const*>(type)->ref;
        }

        _output << "up::reflex::Schema const& up::reflex::SchemaHolder<" << cxx::Type{*type} << ">::get() noexcept {\n";
        _output << "  using namespace up::schema;\n\n";

        writeAnnotations("type_annotations", type->annotations);

        switch (type->kind) {
            case TypeKind::Enum:
                _output << "  static SchemaEnumValue const values[] = {\n";
                for (auto const* const item : static_cast<TypeEnum const&>(*type).items) {
                    _output << "    SchemaEnumValue{.name = \"" << item->name << "\"_zsv, .value = " << item->value
                            << "},\n";
                }
                _output << "  };\n\n";

                _output << "  static Schema const schema = {\n";
                _output << "    .name = \"" << type->name << "\",\n";
                _output << "    .primitive = up::reflex::SchemaPrimitive::Enum,\n";
                _output << "    .elementType = &getSchema<std::underlying_type_t<" << cxx::QualifiedName{*type}
                        << ">>(),\n";
                _output << "    .enumValues = values,\n";
                _output << "    .annotations = type_annotations\n";
                _output << "   };\n\n";

                break;
            case TypeKind::Struct:
            case TypeKind::Attribute:
            case TypeKind::Specialized:
                if (type->kind == TypeKind::Specialized) {
                    type = static_cast<TypeSpecialized const*>(type)->ref;
                }

                if (!static_cast<TypeAggregate const&>(*type).fields.empty()) {
                    for (auto const* const field : static_cast<TypeAggregate const&>(*type).fields) {
                        writeAnnotations("field_annotations_" + field->name, field->annotations);
                    }

                    _output << "  static SchemaField const fields[] = {\n";
                    for (auto const* const field : static_cast<TypeAggregate const&>(*type).fields) {
                        _output << "    SchemaField{\n";
                        _output << "      .name = \"" << field->name << "\",\n";
                        _output << "      .schema = &getSchema<" << cxx::Type{*field->type} << ">(),\n";
                        _output << "      .offset = offsetof(" << cxx::Type{*type} << ", " << cxx::Ident{field->name}
                                << "),\n";
                        _output << "      .annotations = field_annotations_" << cxx::Ident{field->name} << "\n";
                        _output << "    },\n";
                    }
                    _output << "  };\n\n";
                }
                else {
                    _output << "  up::view<SchemaField> const fields;\n\n";
                }

                _output << "  static Schema const schema = {\n";
                _output << "    .name = \"" << type->name << "\",\n";
                _output << "    .primitive = up::reflex::SchemaPrimitive::Object,\n";
                if (static_cast<TypeAggregate const&>(*type).baseType != nullptr) {
                    _output << "    .baseSchema = &getSchema<"
                            << cxx::Type{*static_cast<TypeAggregate const&>(*type).baseType} << ">(),\n";
                }
                _output << "    .fields = fields,\n";
                _output << "    .annotations = type_annotations\n";
                _output << "  };\n\n";
                break;
            case TypeKind::Alias:
                _output << "  static Schema const schema = {\n";
                _output << "    .name = \"" << type->name << "\",\n";
                _output << "    .primitive = up::reflex::SchemaPrimitive::Object,\n";
                _output << "    .baseSchema = &getSchema<" << cxx::Type{*static_cast<TypeIndirect const&>(*type).ref}
                        << ">(),\n";
                _output << "    .annotations = type_annotations\n";
                _output << "  };\n\n";
                break;
            default:
                _output << "  static Schema const schema = {\n";
                _output << "    .name = \"" << type->name << "\",\n";
                _output << "    .annotations = type_annotations\n";
                _output << "  };\n\n";
                break;
        }

        _output << "  return schema;\n";
        _output << "}\n\n";
    }
}

bool SchemaSourceGenerator::allowType(schema::TypeBase const& type) const noexcept {
    using namespace schema;

    // aliases don't need their own info; we just use the base info
    //
    // FIXME: full aliases allowed because specialized types are not in the correct module
    //
    if (type.kind == TypeKind::Alias && static_cast<TypeIndirect const&>(type).ref == nullptr) {
        return false;
    }

    // indirect types don't (currently) get schemas
    //
    if (type.kind == TypeKind::Array || type.kind == TypeKind::Pointer) {
        return false;
    }

    // generic types (non-specialized) don't get schemas
    //
    if (type.kind == TypeKind::TypeParam ||
        (type.kind == TypeKind::Struct && !static_cast<TypeAggregate const&>(type).typeParams.empty())) {
        return false;
    }

    // explicitly ignored types are skipped
    //
    if (hasAnnotation(type.annotations, "ignore")) {
        return false;
    }

    return true;
}

bool SchemaSourceGenerator::allowAttribute(schema::TypeAggregate const& attribute) const noexcept {
    if (attribute.name.front() == '$') {
        return false;
    }

    if (attribute.name.starts_with("cxx")) {
        return false;
    }

    return true;
}
