// Copyright by Potato Engine contributors. See accompanying License.txt for copyright details.

#include "../cxx.h"
#include "../generator.h"
#include "../schema.h"

#include <memory>
#include <ostream>

namespace {
    class SchemaHeaderGenerator final : public Generator {
    public:
        using Generator::Generator;

        bool generate() override;

    private:
        void writeFileHeader();
        void writeIncludes();
        void writeTypeDeclarations();
        void writeTypeDeclaration(schema::TypeBase const& type);
        void writeTypeReflex();

        void enterNamespace(std::string ns);

        std::string _currentNamespace;
    };
} // namespace

std::unique_ptr<Generator> newSchemaHeaderGenerator(GeneratorContext const& ctx) {
    return std::make_unique<SchemaHeaderGenerator>(ctx);
}

bool SchemaHeaderGenerator::generate() {
    writeFileHeader();
    writeIncludes();
    writeTypeDeclarations();
    writeTypeReflex();

    return true;
}

void SchemaHeaderGenerator::writeFileHeader() {
    _output << "// --- GENERATED FILE ----\n"
               "// - Do not edit this file\n"
               "//\n\n"
               "#pragma once\n\n";
}

void SchemaHeaderGenerator::writeIncludes() {
    _output << "// Core includes\n";
    _output << "#include \"" << config("EXPORT_HEADER") << "\"\n";
    _output << R"--(
#include "potato/reflex/schema.h"
#include "potato/reflex/type.h"
#include "potato/spud/string.h"
#include "potato/spud/vector.h"
)--";

    _output << "// Module includes\n";
    for (auto const& imp : _module.imports) {
        _output << "#include \"" << imp << "_schema.h\"\n";
    }

    _output << "// Imported type includes\n";
    for (auto const* type : _module.allTypes) {
        auto const header = schema::getAnnotationArg(type->annotations, "cxximport", 1);
        if (header) {
            _output << "#include \"" << schema::valueCast<std::string_view>(*header) << "\"\n";
        }
    }
}

void SchemaHeaderGenerator::writeTypeDeclarations() {
    using namespace schema;

    _output << "\n// Type declarations\n\n";

    for (TypeBase const* type : _module.exportedTypes) {
        if (hasAnnotation(type->annotations, "ignore")) {
            continue;
        }
        if (hasAnnotation(type->annotations, "cxximport")) {
            continue;
        }

        writeTypeDeclaration(*type);

        _output << "\n";
    }
}

void SchemaHeaderGenerator::writeTypeDeclaration(schema::TypeBase const& type) {
    using namespace schema;

    enterNamespace({});

    switch (type.kind) {
        case TypeKind::Alias:
            enterNamespace(cxx::typeNamespace(type));
            _output << "  using " << cxx::Ident{type.name} << " = "
                    << cxx::Type{_module, *static_cast<TypeIndirect const&>(type).ref} << ";\n";
            break;
        case TypeKind::Enum:
            enterNamespace(cxx::typeNamespace(type));
            _output << "  enum class " << cxx::Ident{type.name} << " {\n";
            for (EnumItem const* item : static_cast<TypeEnum const&>(type).items) {
                _output << "    " << cxx::Ident{item->name} << " = " << item->value << ",\n";
            }
            _output << "  };\n";
            break;
        case TypeKind::Struct:
        case TypeKind::Attribute:
        case TypeKind::Union:
            enterNamespace(cxx::typeNamespace(type));
            if (!static_cast<TypeAggregate const&>(type).typeParams.empty()) {
                _output << "  template <";
                for (auto const& typeParam : static_cast<TypeAggregate const&>(type).typeParams) {
                    _output << typeParam << ", ";
                }
                _output << ">\n";
            }
            _output << "  " << (type.kind == TypeKind::Union ? "union" : "struct") << " " << cxx::Ident{type.name};
            if (type.kind == TypeKind::Attribute) {
                _output << " : reflex::SchemaAttribute";
            }
            else if (static_cast<TypeAggregate const&>(type).baseType != nullptr) {
                _output << " : " << cxx::Type{_module, *static_cast<TypeAggregate const&>(type).baseType};
            }
            _output << " {\n";
            for (Field const* field : static_cast<TypeAggregate const&>(type).fields) {
                _output << "    " << cxx::Type{_module, *field->type} << " " << cxx::Ident{field->name} << ";\n";
            }
            _output << "  };\n";
            break;
        case TypeKind::Simple:
        case TypeKind::TypeParam:
        case TypeKind::Array:
        case TypeKind::Pointer:
        case TypeKind::Specialized:
            // ignore these
            break;
        default:
            fail("Type '{0}' has unknown kind '{1}'", type.name, type.kind);
            break;
    }
}

void SchemaHeaderGenerator::writeTypeReflex() {
    using namespace schema;

    _output << "\n// Reflex and schema holders\n\n";

    for (TypeBase const* type : _module.exportedTypes) {
        if (hasAnnotation(type->annotations, "ignore")) {
            continue;
        }

        if (type->kind == TypeKind::TypeParam || type->kind == TypeKind::Array || type->kind == TypeKind::Pointer) {
            continue;
        }

        if (type->kind == TypeKind::Struct && !static_cast<TypeAggregate const*>(type)->typeParams.empty()) {
            continue;
        }

        enterNamespace("up::reflex");

        _output << "  template<>\n";
        _output << "  struct TypeHolder<" << cxx::Type{_module, *type} << "> {\n";
        _output << "      " << config("EXPORT_MACRO") << " static TypeInfo const &get() noexcept;\n";
        _output << "  };\n\n";

        _output << "  template<>\n";
        _output << "  struct SchemaHolder<" << cxx::Type{_module, *type} << "> {\n";
        _output << "      " << config("EXPORT_MACRO") << " static Schema const& get() noexcept;\n";
        _output << "  };\n\n";
    }

    enterNamespace({});
}

void SchemaHeaderGenerator::enterNamespace(std::string ns) {
    if (ns == _currentNamespace) {
        return;
    }

    if (!_currentNamespace.empty()) {
        _output << "} /* namespace " << _currentNamespace << " */\n\n";
    }

    _currentNamespace = std::move(ns);

    if (!_currentNamespace.empty()) {
        _output << "namespace " << _currentNamespace << " {\n";
    }
}
