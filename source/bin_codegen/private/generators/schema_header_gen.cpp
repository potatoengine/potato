// Copyright by Potato Engine contributors. See accompanying License.txt for copyright details.

#include "../cxx.h"
#include "../generator.h"
#include "../schema.h"

#include <memory>
#include <ostream>

namespace {
    class SchemaHeaderGenerator final : public Generator {
    public:
        using Generator::Generator;

        bool generate() override;

    private:
        void writeFileHeader();
        void writeIncludes();
        void writeTypeDeclarations();

        void enterNamespace(std::string ns);

        std::string _currentNamespace;
    };
} // namespace

std::unique_ptr<Generator> newSchemaHeaderGenerator(GeneratorContext const& ctx) {
    return std::make_unique<SchemaHeaderGenerator>(ctx);
}

bool SchemaHeaderGenerator::generate() {
    writeFileHeader();
    writeIncludes();
    writeTypeDeclarations();

    return true;
}

void SchemaHeaderGenerator::writeFileHeader() {
    _output << "// --- GENERATED FILE ----\n"
               "// - Do not edit this file\n"
               "//\n";
}

void SchemaHeaderGenerator::writeIncludes() {
    _output << R"--(
#include "potato/reflex/schema.h"
#include "potato/reflex/type.h"
#include "potato/spud/string.h"
#include "potato/spud/vector.h"
)--";

    for (auto const& imp : _module.imports) {
        _output << "#include \"" << imp << "_schema.h\"\n";
    }
}

void SchemaHeaderGenerator::writeTypeDeclarations() {
    using namespace schema;
    using namespace std::literals;

    for (TypeBase const* type : _module.exportedTypes) {
        if (hasAnnotation(type->annotations, "ignore")) {
            continue;
        }
        if (hasAnnotation(type->annotations, "cxximport")) {
            continue;
        }

        switch (type->kind) {
            case TypeKind::Alias:
                enterNamespace(cxx::typeNamespace(*type));
                _output << "  using " << cxx::Ident{type->name} << " = "
                        << cxx::QualifiedName{static_cast<TypeIndirect const*>(type)->ref} << ";\n";
                break;
            case TypeKind::Enum:
                enterNamespace(cxx::typeNamespace(*type));
                _output << "  enum class " << cxx::Ident{type->name} << " {\n";
                _output << "  };\n";
                //    if type.base is not None:
                //        ctx.print(f' : {qualified_cxxname(type.base)}')
                //    ctx.print(' {\n')
                //    for key in type.names:
                //        ctx.print(f'        {key} = {type.value_or(key, 0)},\n')
                //    ctx.print("    };\n")
                break;
            case TypeKind::Struct:
                enterNamespace(cxx::typeNamespace(*type));
                _output << "  struct " << cxx::Ident{type->name} << " {\n";
                for (Field const* field : static_cast<TypeAggregate const*>(type)->fields) {
                    _output << "    " << cxx::Type{&_module, field->type} << " " << cxx::Ident{field->name} << ";\n";
                }
                _output << "  };\n";
                break;
            case TypeKind::Attribute:
                enterNamespace(cxx::typeNamespace(*type));
                _output << "  struct " << cxx::Ident{type->name} << " : reflex::SchemaAttribute {\n";
                for (Field const* field : static_cast<TypeAggregate const*>(type)->fields) {
                    _output << "    " << cxx::QualifiedName{field->type} << " " << cxx::Ident{field->name} << ";\n";
                }
                _output << "  };\n";
                break;
            case TypeKind::Union:
                enterNamespace(cxx::typeNamespace(*type));
                _output << "  union " << cxx::Ident{type->name} << " {\n";
                for (Field const* field : static_cast<TypeAggregate const*>(type)->fields) {
                    _output << "    " << cxx::QualifiedName{field->type} << " " << cxx::Ident{field->name} << ";\n";
                }
                _output << "  };\n";
                break;
            case TypeKind::Simple:
            case TypeKind::TypeParam:
            case TypeKind::Array:
            case TypeKind::Pointer:
            case TypeKind::Specialized:
                // ignore these
                break;
            default:
                fail("Type '{0}' has unknown kind '{1}'", type->name, type->kind);
                break;
        }
    }

    enterNamespace({});
}

void SchemaHeaderGenerator::enterNamespace(std::string ns) {
    if (ns == _currentNamespace) {
        return;
    }

    if (!_currentNamespace.empty()) {
        _output << "} /* namespace " << _currentNamespace << " */\n\n";
    }

    _currentNamespace = std::move(ns);

    if (!_currentNamespace.empty()) {
        _output << "namespace " << _currentNamespace << " {\n";
    }
}
