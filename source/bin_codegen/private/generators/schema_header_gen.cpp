// Copyright by Potato Engine contributors. See accompanying License.txt for copyright details.

#include "../cxx.h"
#include "../generator.h"
#include "../schema.h"

#include <memory>
#include <ostream>

namespace {
    class SchemaHeaderGenerator final : public Generator {
    public:
        using Generator::Generator;

        bool generate() override;

    private:
        void writeFileHeader();
        void writeIncludes();
        void writeTypeDeclarations();
        void writeTypeDeclaration(schema::TypeBase const& type);
        void writeTypeReflex();

        void enterNamespace(std::string ns);

        bool allowType(schema::TypeBase const& type) const noexcept;

        std::string _currentNamespace;
    };
} // namespace

std::unique_ptr<Generator> newSchemaHeaderGenerator(GeneratorContext const& ctx) {
    return std::make_unique<SchemaHeaderGenerator>(ctx);
}

bool SchemaHeaderGenerator::generate() {
    writeFileHeader();
    writeIncludes();
    writeTypeDeclarations();
    writeTypeReflex();

    return true;
}

void SchemaHeaderGenerator::writeFileHeader() {
    _output << "// --- GENERATED FILE ----\n"
               "// - Do not edit this file\n"
               "//\n\n"
               "#pragma once\n\n";
}

void SchemaHeaderGenerator::writeIncludes() {
    _output << "// Core includes\n";
    _output << "#include \"" << config("EXPORT_HEADER") << "\"\n";
    _output << R"--(
#include "potato/reflex/schema.h"
#include "potato/reflex/type.h"
#include "potato/spud/string.h"
#include "potato/spud/vector.h"
)--";

    _output << "// Module includes\n";
    for (auto const& imp : _module.imports) {
        _output << "#include \"" << imp << "_schema.h\"\n";
    }

    _output << "// Imported type includes\n";
    for (auto const* type : _module.allTypes) {
        auto const header = schema::getAnnotationArg(type->annotations, "cxximport", 1);
        if (header) {
            _output << "#include \"" << schema::valueCast<std::string_view>(*header) << "\"\n";
        }
    }
}

void SchemaHeaderGenerator::writeTypeDeclarations() {
    using namespace schema;

    _output << "\n// Type declarations\n\n";

    for (TypeBase const* type : _module.exportedTypes) {
        if (!allowType(*type)) {
            continue;
        }

        if (type->kind == TypeKind::Alias) {
            // hack because specialized types aren't owned by correct module
            writeTypeDeclaration(*static_cast<schema::TypeIndirect const*>(type)->ref);
        }
        else {
            writeTypeDeclaration(*type);
        }

        _output << "\n";
    }

    enterNamespace({});
}

void SchemaHeaderGenerator::writeTypeDeclaration(schema::TypeBase const& type) {
    using namespace schema;

    switch (type.kind) {
        case TypeKind::Alias:
            enterNamespace(cxx::typeNamespace(type));
            _output << "  using " << cxx::Ident{type.name} << " = "
                    << cxx::Type{*static_cast<TypeIndirect const&>(type).ref} << ";\n";
            break;
        case TypeKind::Enum:
            enterNamespace(cxx::typeNamespace(type));
            _output << "  enum class " << cxx::Ident{type.name} << " {\n";
            for (EnumItem const* item : static_cast<TypeEnum const&>(type).items) {
                _output << "    " << cxx::Ident{item->name} << " = " << item->value << ",\n";
            }
            _output << "  };\n";
            break;
        case TypeKind::Struct:
        case TypeKind::Attribute:
        case TypeKind::Union:
            enterNamespace(cxx::typeNamespace(type));
            if (!static_cast<TypeAggregate const&>(type).typeParams.empty()) {
                _output << "  template <";
                for (auto const& typeParam : static_cast<TypeAggregate const&>(type).typeParams) {
                    _output << typeParam << ", ";
                }
                _output << ">\n";
            }
            _output << "  " << (type.kind == TypeKind::Union ? "union" : "struct") << " " << cxx::Ident{type.name};
            if (type.kind == TypeKind::Attribute) {
                _output << " : reflex::SchemaAttribute";
            }
            else if (static_cast<TypeAggregate const&>(type).baseType != nullptr) {
                _output << " : " << cxx::Type{*static_cast<TypeAggregate const&>(type).baseType};
            }
            _output << " {\n";
            for (Field const* field : static_cast<TypeAggregate const&>(type).fields) {
                _output << "    " << cxx::Type{*field->type} << " " << cxx::Ident{field->name} << ";\n";
            }
            _output << "  };\n";
            break;
        case TypeKind::Simple:
        case TypeKind::TypeParam:
        case TypeKind::Array:
        case TypeKind::Pointer:
        case TypeKind::Specialized:
            // ignore these
            break;
        default:
            fail("Type '{0}' has unknown kind '{1}'", type.name, type.kind);
            break;
    }
}

void SchemaHeaderGenerator::writeTypeReflex() {
    using namespace schema;

    _output << "\n// Reflex and schema holders\n\n";

    for (TypeBase const* type : _module.exportedTypes) {
        if (!allowType(*type)) {
            _output << "  // disallowed: " << type->qualifiedName << "\n";
            continue;
        }

        // hack because specialized types aren't owned by correct module
        //
        if (type->kind == TypeKind::Alias) {
            type = static_cast<schema::TypeIndirect const*>(type)->ref;
        }

        enterNamespace("up::reflex");

        _output << "  template<>\n";
        _output << "  struct TypeHolder<" << cxx::Type{*type} << "> {\n";
        _output << "      " << config("EXPORT_MACRO") << " static TypeInfo const &get() noexcept;\n";
        _output << "  };\n\n";

        _output << "  template<>\n";
        _output << "  struct SchemaHolder<" << cxx::Type{*type} << "> {\n";
        _output << "      " << config("EXPORT_MACRO") << " static Schema const& get() noexcept;\n";
        _output << "  };\n\n";
    }

    enterNamespace({});
}

void SchemaHeaderGenerator::enterNamespace(std::string ns) {
    if (ns == _currentNamespace) {
        return;
    }

    if (!_currentNamespace.empty()) {
        _output << "} /* namespace " << _currentNamespace << " */\n\n";
    }

    _currentNamespace = std::move(ns);

    if (!_currentNamespace.empty()) {
        _output << "namespace " << _currentNamespace << " {\n";
    }
}

bool SchemaHeaderGenerator::allowType(schema::TypeBase const& type) const noexcept {
    using namespace schema;

    // aliases don't need their own info; we just use the base info
    //
    // FIXME: aliases allowed because specialized types are not in the correct module
    //
    if (type.kind == TypeKind::Alias && static_cast<TypeIndirect const&>(type).ref == nullptr) {
        return false;
    }

    // indirect types don't (currently) get schemas
    //
    if (type.kind == TypeKind::Array || type.kind == TypeKind::Pointer) {
        return false;
    }

    // generic types (non-specialized) don't get schemas
    //
    if (type.kind == TypeKind::TypeParam ||
        (type.kind == TypeKind::Struct && !static_cast<TypeAggregate const&>(type).typeParams.empty())) {
        return false;
    }

    // explicitly ignored types are skipped
    //
    if (hasAnnotation(type.annotations, "ignore")) {
        return false;
    }

    return true;
}
