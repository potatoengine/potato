// Copyright by Potato Engine contributors. See accompanying License.txt for copyright details.

#include "generator.h"
#include "schema.h"

#include <nlohmann/json.hpp>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <memory>
#include <string>
#include <string_view>

extern std::unique_ptr<Generator> newSchemaHeaderGenerator(GeneratorContext const& ctx);

static void usage(char const* program);
static std::unique_ptr<Generator> selectGenerator(std::string_view mode, GeneratorContext const& ctx);
static bool generate(std::string_view mode, std::ostream& output, schema::Module const& mod);

// NOLINTNEXTLINE(bugprone-exception-escape)
int main(int argc, char const* argv[]) {
    using namespace std::literals;

    std::filesystem::path inputPath;
    std::filesystem::path outputPath;
    std::string mode;

    for (int argi = 1; argi != argc; ++argi) {
        if (argv[argi] == "-m"sv && argi < argc - 1) {
            mode = argv[++argi];
        }
        else if (argv[argi] == "-i"sv && argi < argc - 1) {
            inputPath = argv[++argi];
        }
        else if (argv[argi] == "-o"sv && argi < argc - 1) {
            outputPath = argv[++argi];
        }
        else {
            std::cerr << "Unknown argument '" << argv[argi] << "'\n";
            usage(argv[0]);
            return 1;
        }
    }

    if (inputPath.empty()) {
        std::cerr << "Missing input path argument\n";
        usage(argv[0]);
        return 1;
    }

    if (outputPath.empty()) {
        std::cerr << "Missing output path argument\n";
        usage(argv[0]);
        return 1;
    }

    std::ifstream input(inputPath, std::ios::binary);
    if (!input) {
        std::cerr << "Failed to open `" << inputPath << "` for reading\n";
        return 2;
    }

    schema::Module mod;
    try {
        if (!schema::loadModule(input, mod)) {
            std::cerr << "Failed to parse JSON in `" << inputPath << "`\n";
            return 4;
        }
    }
    catch (nlohmann::json::exception const& ex) {
        std::cerr << "Fatal error: " << ex.what() << "\n";
        return 6;
    }
    input.close();

    std::ofstream output(outputPath, std::ios::binary | std::ios::trunc);
    if (!output) {
        std::cerr << "Failed to open `" << outputPath << "` for writing\n";
        return 3;
    }

    output << "// Generated by " << argv[0] << '\n';

    auto const rs = generate(mode, output, mod);

    output.close();

    return rs ? 0 : 5;
}

void usage(char const* program) {
    std::cerr << "Usage: " << program << " -m <mode> -i <input> -o <output>\n ";
}

std::unique_ptr<Generator> selectGenerator(std::string_view mode, GeneratorContext const& ctx) {
    using namespace std::literals;

    if (mode == "schema_header"sv) {
        return newSchemaHeaderGenerator(ctx);
    }

    return nullptr;
}

bool generate(std::string_view mode, std::ostream& output, schema::Module const& mod) {
    auto const gen = selectGenerator(mode, {output, mod});
    if (gen == nullptr) {
        std::cerr << "Unknown mode '" << mode << "'\n";
        return false;
    }

    auto const rs = gen->generate();
    if (!rs) {
        std::cerr << "Generator '" << mode << "' failed\n";
        return false;
    }

    if (gen->errors() != 0) {
        return false;
    }

    return true;
}
