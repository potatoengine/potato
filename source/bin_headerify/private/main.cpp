// Copyright by Potato Engine contributors. See accompanying License.txt for copyright details.

#include <filesystem>
#include <fstream>
#include <iostream>
#include <memory>
#include <string>

namespace fs = std::filesystem;

// NOLINTNEXTLINE(bugprone-exception-escape)
int main(int argc, char const* argv[]) {
    if (argc != 4) {
        std::cerr << "Usage: headerify <input> <output> <name>\n";
        return 1;
    }

    std::string inputPath{argv[1]};
    std::string outputPath{argv[2]};
    std::string name{argv[3]};

    std::ifstream input(inputPath, std::ios::binary);
    if (!input) {
        std::cerr << "Failed to open `" << inputPath << "` for reading\n";
        return 2;
    }

    std::ofstream output(outputPath, std::ios::binary | std::ios::trunc);
    if (!output) {
        std::cerr << "Failed to open `" << outputPath << "` for writing\n";
        return 3;
    }

    constexpr int bufferSize = 1 * 1024 * 1024;
    std::unique_ptr<char[]> buffer(new char[bufferSize]);

    output << "// Generated by " << argv[0] << '\n';
    output << "static constexpr unsigned char " << name << "_data[] = {\n  ";

    int lineCounter = 0;
    constexpr int maxPerLine = 16;
    size_t totalBytes = 0;

    output << std::hex << std::showbase;

    while (!input.eof() && !input.fail() && !output.fail()) {
        input.read(buffer.get(), bufferSize);

        auto size = input.gcount();
        totalBytes += size;

        for (decltype(size) index = 0; index != size; ++index) {
            output << static_cast<unsigned int>(static_cast<unsigned char>(buffer.get()[index])) << ", ";
            if (++lineCounter == maxPerLine) {
                lineCounter = 0;
                output << "\n  ";
            }
        }
    }

    if (!input.eof() && input.fail()) {
        std::cerr << "Failed to read from `" << inputPath << "`\n";
        return 4;
    }

    input.close();

    output << std::dec << std::noshowbase;

    output << "\n};\nstatic constexpr int " << name << "_size = " << totalBytes << ";\n";

    if (output.fail()) {
        std::cerr << "Failed to write to `" << outputPath << "`\n";
        return 5;
    }

    output.close();

    return 0;
}
