// Copyright by Potato Engine contributors. See accompanying License.txt for copyright details.

#include <filesystem>
#include <fstream>
#include <iostream>
#include <memory>
#include <string>

namespace fs = std::filesystem;

int main(int argc, char const* argv[]) {
    try {
        if (argc != 4) {
            std::cerr << "Usage: headerify <input> <output> <name>\n";
            return 1;
        }

        fs::path inputPath{argv[1]};
        fs::path outputPath{argv[2]};
        std::string name{argv[3]};

        std::ifstream input(inputPath, std::ios::binary);
        if (!input) {
            std::cerr << "Failed to open `" << inputPath.generic_string() << "` for reading\n";
            return 2;
        }

        std::ofstream output(outputPath, std::ios::binary | std::ios::trunc);
        if (!output) {
            std::cerr << "Failed to open `" << outputPath.generic_string() << "` for writing\n";
            return 3;
        }

        constexpr int bufferSize = 1 * 1024 * 1024;
        std::unique_ptr<char[]> buffer(new char[bufferSize]);

        output << "// Generated by " << argv[0] << '\n';
        output << "static constexpr unsigned char " << name << "_data[] = {\n  ";

        int lineCounter = 0;
        constexpr int maxPerLine = 16;
        size_t totalBytes = 0;

        output << std::hex << std::showbase;

        while (!input.eof() && !input.fail() && !output.fail()) {
            input.read(buffer.get(), bufferSize);

            auto size = input.gcount();
            totalBytes += size;

            for (decltype(size) index = 0; index != size; ++index) {
                output << static_cast<unsigned int>(static_cast<unsigned char>(buffer.get()[index])) << ", ";
                if (++lineCounter == maxPerLine) {
                    lineCounter = 0;
                    output << "\n  ";
                }
            }
        }

        if (!input.eof() && input.fail()) {
            std::cerr << "Failed to read from `" << inputPath.generic_string() << "`\n";
            return 4;
        }

        input.close();

        output << std::dec << std::noshowbase;

        output << "\n};\nstatic constexpr int " << name << "_size = " << totalBytes << ";\n";

        if (output.fail()) {
            std::cerr << "Failed to write to `" << outputPath.generic_string() << "`\n";
            return 5;
        }

        output.close();

        return 0;
    }
    catch (std::exception& ex) {
        std::cerr << "Exception: " << ex.what() << '\n';
        return 6;
    }
}
